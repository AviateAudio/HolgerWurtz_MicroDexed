/*
 * Company: Holger Wurtz
 * Effect Name: MicroDexed
 * Description: FM synthesis inspired by DX7 and similar synths.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#pragma once

#include <Audio.h>
#include <arm_math.h>
#include "Aviate/AudioEffectWrapper.h"

//!s - START_USER_INCLUDES - put your #includes below this line before the matching END
#include <array>
class Dexed;  // forward declare
//!e - END_USER_INCLUDES

namespace HolgerWurtz_MicroDexed {

//!s - START_USER_EFFECT_TYPES - put your effect types below this line before the matching END
enum class InstrumentCategory : unsigned {
    PIANO,
    ORGAN,
    STRINGS,
    SYNTH,
    BRASS,
    WINDS,
    BASS,
    BELLS,
    PERCUSS,
    EXTRA
};
//!e - END_USER_EFFECT_TYPES

class MicroDexed : public AudioStream, public Aviate::AudioEffectFloat {
public:
    static constexpr unsigned NUM_INPUTS  = 0;
    static constexpr unsigned NUM_OUTPUTS = 1;

    // Some useful aliases
    using AudioBlock    = audio_block_float32_t;
    using AudioDataType = float;

    // List of effect control names
    enum {
        Bypass_e = 0,
        Volume_e = 1,
        Transpose_e = 2,
        Category_e = 3,
        Piano_e = 4,
        Organ_e = 5,
        Strings_e = 6,
        Synth_e = 7,
        Brass_e = 8,
        Winds_e = 9,
        Bass_e = 10,
        Bells_e = 11,
        Percussion_e = 12,
        Extra_e = 13,
        BankSelect_e = 14,
        VoiceSelect_e = 15,
        NUM_CONTROLS
    };

    //!s - START_USER_CLASS_TYPES - put your custom class types below this line before the matching END
    //!e - END_USER_CLASS_TYPES

    MicroDexed();

    //!s - START_USER_CONSTRUCTORS - put your custom constructors below this line before the matching END
    //!e - END_USER_CONSTRUCTORS

    virtual ~MicroDexed();

    // Standard EFX interface functions - do not change these declaration
    virtual void update(); // main audio processing loop function
    void mapMidiControl(int parameter, int midiCC, int midiChannel = 0) override;
    void processMidi(int status, int data1, int data2) override;
    void setParam(int paramIndex, float paramValue) override;
    float getUserParamValue(int paramIndex, float normalizedParamValue);
    const char* getName() override;
    const uint8_t* getRblk() override;

    // control value set functions, must take floats between 0.0f and 1.0f - do not change these declarations
    void volume(float value) override;
    void transpose(float value);
    void category(float value);
    void piano(float value);
    void organ(float value);
    void strings(float value);
    void synth(float value);
    void brass(float value);
    void winds(float value);
    void bass(float value);
    void bells(float value);
    void percussion(float value);
    void extra(float value);
    void bankselect(float value);
    void voiceselect(float value);

    //!s - START_USER_PUBLIC_MEMBERS - put your public members below this line before the matching END
    //!e - END_USER_PUBLIC_MEMBERS

private:
    AudioBlock *m_inputQueueArray[NUM_INPUTS]; // pass an array of zero size to the base class for 0 inputs
    int m_midiConfig[NUM_CONTROLS][2]; // stores the midi parameter mapping

    // m_bypass and m_volume are already provided by the base class AudioEffectWrapper or AudioEffectFloat
    float m_transpose = 0.0f;
    float m_category = 0.0f;
    float m_piano = 0.0f;
    float m_organ = 0.0f;
    float m_strings = 0.0f;
    float m_synth = 0.0f;
    float m_brass = 0.0f;
    float m_winds = 0.0f;
    float m_bass = 0.0f;
    float m_bells = 0.0f;
    float m_percussion = 0.0f;
    float m_extra = 0.0f;
    float m_bankselect = 0.0f;
    float m_voiceselect = 0.0f;

    bool m_enableAndBypassCheck(unsigned numOutputs);  // returns false if disabled or bypassed

    //!s - START_USER_PRIVATE_MEMBERS - put your private members below this line before the matching END
    float AUDIO_SAMPLES_PER_BLOCK_INV;
    Dexed* m_dexed;
    const uint16_t audio_block_time_us = 1000000 / (AUDIO_SAMPLE_RATE_EXACT / AUDIO_BLOCK_SAMPLES);
    volatile bool in_update = false;

    void m_init();
    bool m_isInit = false;
    void m_setVoice(unsigned bank, unsigned voice, unsigned tranpose);
    unsigned bankSel = 0;
    unsigned voiceSel = 0;
    unsigned m_transposeSel = 0;

    void m_updateVoiceRequest();
    void m_updateVoice();
    void m_setInstrument(InstrumentCategory category, unsigned instEnum, float& var, float value, unsigned& sel, 
                         unsigned numVoices, const char* name);
    InstrumentCategory m_categorySel = InstrumentCategory::PIANO;
    unsigned m_pianoSel     = 0;
    unsigned m_organSel     = 0;
    unsigned m_stringsSel   = 0;
    unsigned m_synthSel     = 0;
    unsigned m_brassSel     = 0;
    unsigned m_windsSel     = 0;
    unsigned m_bassSel      = 0;
    unsigned m_bellsSel     = 0;
    unsigned m_percussSel   = 0;
    unsigned m_extraSel = 0;

    static constexpr unsigned MAX_NOTES = 16;
    enum class VoiceUpdate : unsigned { IDLE, MUTING, ATTACKING };
    VoiceUpdate m_voiceUpdate;
    struct notes_t {
        bool    playing = false;
        uint8_t note;
        uint8_t velocity;
    };
    std::array<notes_t, MAX_NOTES> m_noteArray;
    void m_addNote(uint8_t note, uint8_t velocity);
    void m_removeNote(uint8_t note, uint8_t velocity);

    //!e - END_USER_PRIVATE_MEMBERS

};

}
