/*
 * Company: Holger Wurtz
 * Effect Name: MicroDexed
 * Description: Yamaha DX7
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include "Aviate/EfxPrint.h"
#include "MicroDexed.h"
#include "sysPlatform/SysTimer.h"
#include "dexed.h"
#include "voices.h"
#include "banks.h"
#include "preset_piano.h"
#include "preset_organ.h"

using namespace Aviate;

// #define SYNTH_DEXED_VERSION "1.0.1"
// //#define DEBUG 1
// #define SAMPLE_RATE 44100

// #define TRANSPOSE_FIX 24
// #define VOICE_SILENCE_LEVEL 1100

// #define _MAX_NOTES 32

// #define PB_RANGE_DEFAULT 1
// #define PB_STEP_DEFAULT 0
// #define MW_RANGE_DEFAULT 50
// #define MW_ASSIGN_DEFAULT 0 // Bitmapped: 0: Pitch, 1: Amp, 2: Bias
// #define MW_MODE_DEFAULT 0
// #define FC_RANGE_DEFAULT 50
// #define FC_ASSIGN_DEFAULT 0 // Bitmapped: 0: Pitch, 1: Amp, 2: Bias
// #define FC_MODE_DEFAULT 0
// #define BC_RANGE_DEFAULT 50
// #define BC_ASSIGN_DEFAULT 0 // Bitmapped: 0: Pitch, 1: Amp, 2: Bias
// #define BC_MODE_DEFAULT 0
// #define AT_RANGE_DEFAULT 50
// #define AT_ASSIGN_DEFAULT 0 // Bitmapped: 0: Pitch, 1: Amp, 2: Bias
// #define AT_MODE_DEFAULT 0
// #define PORTAMENTO_MODE_DEFAULT 0 // 0: Retain, 1: Follow
// #define PORTAMENTO_GLISSANDO_DEFAULT 0
// #define PORTAMENTO_TIME_DEFAULT 0

namespace HolgerWurtz_MicroDexed {

MicroDexed::MicroDexed()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    // perform any necessary class initialization here
    m_dexed = new Dexed(4, AUDIO_SAMPLE_RATE_EXACT);
}

MicroDexed::~MicroDexed()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
    if (m_dexed) delete m_dexed;
}

void MicroDexed::m_init()
{
    //m_dexed->loadInitVoice();
    // m_dexed->loadVoiceParameters(fmpiano_sysex);
    // m_dexed->setTranspose(36);
    m_transposeSel = 0;
    m_categorySel = InstrumentCategory::PIANO;
    m_pianoSel = 0;
    m_organSel = 0;
    m_updateVoice();
    m_isInit = true;
}

void MicroDexed::update(void)
{
    if (!m_isInit) { m_init(); }
    audio_block_float32_t *inputAudioBlock = receiveWritableFloat(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass
    if (!inputAudioBlock) { in_update = false; return; } // no further processing for this update() call

    audio_block_float32_t* output = allocateFloat();
    if (!output) { release(inputAudioBlock); in_update = false; return; }

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    if (in_update == true)
    {
        m_dexed->xrun++;
        return;
    }
    else
       in_update = true;

    SysPlatform::ElapsedMicros render_time;

    m_dexed->getSamples(output->data, AUDIO_BLOCK_SAMPLES);

    if (render_time > audio_block_time_us) // everything greater audio_block_time_us (2.9ms for buffer size of 128) is a buffer underrun!
        m_dexed->xrun++;

    if (render_time > m_dexed->render_time_max)
        m_dexed->render_time_max = render_time;

    // DO AUDIO EFFECT PROCESSING
    for (unsigned idx=0; idx<AUDIO_SAMPLES_PER_BLOCK; idx++) {

        //inputAudioBlock->data[idx] = m_volume*output->data[idx] + (1.0f - m_volume)*inputAudioBlock->data[idx]; // we re-use the input audio block
        //inputAudioBlock->data[idx] = 0 + (1.0f - m_volume)*inputAudioBlock->data[idx];
        //inputAudioBlock->data[idx] = m_volume*inputAudioBlock->data[idx];
        output->data[idx] *= m_volume;
    }

    m_updateOutputPeak(output); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(output);
    release(output);
    release(inputAudioBlock);

    in_update = false;
}

void MicroDexed::volume(float value)
{
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectFloat has built-in volume function in dB

    // Demonstrate the efxLogger.printf() function to print over the USB serial port
    // Note: efxLogger.printf() statements will have no effect in RELEASE builds
    efxLogger.printf("volume change: normalized value: %f  dB value: %f\n", value, volDbValue);
}

// void MicroDexed::bankselect(float value)
// {
//     // m_bankselect = getUserParamValue(BankSelect_e, value);
//     // bankSel = static_cast<unsigned>(m_bankselect)-1;
//     // efxLogger.printf("MicroDexed::bankselect: %u\n", bankSel);
//     // if (bankSel >= 0 && bankSel < NUM_BANKS) {
//     //     m_setVoice(bankSel, voiceSel, transposeSel);
//     // }
// }

// void MicroDexed::voiceselect(float value)
// {
//     // m_voiceselect = getUserParamValue(VoiceSelect_e, value);
//     // voiceSel = static_cast<unsigned>(m_voiceselect)-1;
//     // efxLogger.printf("MicroDexed::voiceselect: %u\n", voiceSel);
//     // if (voiceSel >= 0 && voiceSel < NUM_VOICES_PER_BANK) {
//     //     m_setVoice(bankSel, voiceSel, transposeSel);
//     // }
// }

void MicroDexed::transpose(float value)
{
    m_transpose = getUserParamValue(Transpose_e, value);
    m_transposeSel = static_cast<unsigned>(m_transpose);
    efxLogger.printf("MicroDexed::tranpose: %u\n", m_transposeSel);
    m_updateVoice();
    // if (transposeSel >= 0 && transposeSel < MAX_NUM_TRANSPOSE) {
    //     m_setVoice(bankSel, voiceSel, transposeSel);
    // }
}

// void MicroDexed::m_setVoice(unsigned bank, unsigned voice, unsigned tranpose)
// {
//     char voice_name[11];
//     uint8_t decoded_voice[156];

//     memset(voice_name, 0, 11);
//     memcpy(voice_name, &progmem_bank[bank][voice][118], 10);

//     efxLogger.printf("MicroDexed::m_setVoice(): Voice name: %s  Bank/Voice/Trans: %u/%u/%u\n", voice_name, bank, voice, tranpose);

//     m_dexed->decodeVoice(decoded_voice, progmem_bank[bank][voice]);
//     m_dexed->loadVoiceParameters(decoded_voice);
//     m_dexed->setTranspose(tranpose);

//     // // print out all names
//     // for (int i=0; i < NUM_BANKS; i++) {
//     //     efxLogger.printf("\nBank %u\n", i);
//     //     for (int j=0; j < NUM_VOICES_PER_BANK; j++) {
//     //         char name[11];
//     //         memset(name, 0, 11);
//     //         memcpy(name, &progmem_bank[i][j][118], 10);
//     //         //efxLogger.printf("%s,", name);
//     //         efxLogger.printf("v:%u -> %s\n", j, name);
//     //     }
//     //     for (int j=0; j < NUM_VOICES_PER_BANK; j++) {
//     //         char name[11];
//     //         memset(name, 0, 11);
//     //         memcpy(name, &progmem_bank[i][j][118], 10);
//     //         efxLogger.printf("%s,", name);
//     //         if (j % 8 == 0) efxLogger.printf("\n");
//     //     }
//     //     efxLogger.printf("\n");
//     // }
//     // efxLogger.printf("\n");
// }


void MicroDexed::processMidi(int status, int data1, int data2) {
    uint8_t type = status & 0xF0U;
    uint8_t channel = status & 0x0FU;
    efxLogger.printf("MicroDexed::processMidi(): type:%02X channel:%02X  data1:%d  data2:%d\n", type, channel, data1, data2);

    uint8_t note = data1;
    uint8_t velocity = data2;
    const uint8_t midibase=1; //Midi channel OM, LM=midibase+

    if (type == 0x90U) {
        m_dexed->keydown(data1, data2);
    }

    else if (type == 0x80U) {
        m_dexed->keyup(data1);
    }
}

void MicroDexed::m_updateVoice()
{
    uint8_t decoded_voice[156];
    switch(m_categorySel) {
    case InstrumentCategory::PIANO :
        efxLogger.printf("MicroDexed::m_updateVoice(): PIANO set to voice %u, transpose %u\n", m_pianoSel, m_transposeSel);
        m_dexed->decodeVoice(decoded_voice, piano_bank[m_pianoSel]); break;
    case InstrumentCategory::ORGAN :
        efxLogger.printf("MicroDexed::m_updateVoice(): ORGAN set to voice %u, transpose %u\n", m_organSel, m_transposeSel);
        m_dexed->decodeVoice(decoded_voice, organ_bank[m_organSel]);break;
    // case InstrumentCategory::STR_BOW : break;
    // case InstrumentCategory::STR_PLUCK : break;
    // case InstrumentCategory::BRASS : break;
    // case InstrumentCategory::WINDS : break;
    // case InstrumentCategory::BASS : break;
    // case InstrumentCategory::BELLS : break;
    // case InstrumentCategory::PERCUSS : break;
    default : return;;
    }

    m_dexed->loadVoiceParameters(decoded_voice);
    m_dexed->setTranspose(m_transposeSel);
}

void MicroDexed::category(float value)
{
    m_category = getUserParamValue(Category_e, value);
    m_categorySel = static_cast<InstrumentCategory>(m_category);
    efxLogger.printf("MicroDexed::category select: %u\n", m_categorySel);
    m_updateVoice();
}

void MicroDexed::piano(float value)
{
    m_piano = getUserParamValue(Piano_e, value);
    m_pianoSel = static_cast<unsigned>(m_piano);
    efxLogger.printf("MicroDexed::piano select: %u\n", m_pianoSel);
    if (m_pianoSel < 0) { m_pianoSel = 0; }
    if (m_pianoSel >= NUM_PIANO_VOICES) { m_pianoSel = NUM_PIANO_VOICES-1; }
    if (m_categorySel == InstrumentCategory::PIANO) { m_updateVoice(); }
}
void MicroDexed::organ(float value)
{
    m_organ = getUserParamValue(Organ_e, value);
    m_organSel = static_cast<unsigned>(m_organ);
    efxLogger.printf("MicroDexed::organ select: %u\n", m_organSel);
    if (m_organSel < 0) { m_organSel = 0; }
    if (m_organSel >= NUM_PIANO_VOICES) { m_organSel = NUM_PIANO_VOICES-1; }
    if (m_categorySel == InstrumentCategory::ORGAN) { m_updateVoice(); }
}

///////////////
// COMPRESSOR
///////////////
void MicroDexed::compressorenable(float value)
{
    m_compressorenable = value;
    bool enable = static_cast<bool>(m_compressorenable);
    m_dexed->setCompressor(enable);
    efxLogger.printf("MicroDexed::compressor enable: %u\n", enable);
}

// pregain in dB
void MicroDexed::compressorpregain(float value)
{
    m_compressorpregain = getUserParamValue(CompressorPregain_e, value);
    m_dexed->setCompressorPreGain_dB(m_compressorpregain);
    efxLogger.printf("MicroDexed::compressor pregain (dB): %f\n", m_compressorpregain);
}

void MicroDexed::compressorattack(float value)
{
    m_compressorattack = getUserParamValue(CompressorAttack_e, value);
    m_dexed->setCompressorAttack_sec(m_compressorattack / 1000.0f);
    efxLogger.printf("MicroDexed::compressor attack (msec): %f\n", m_compressorattack);
}

}
